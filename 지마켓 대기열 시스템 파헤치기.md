- https://dev.gmarket.com/46


개요 : 
```
추석전에 지마켓에서 쿠폰 이벤트를 진행했고 이때 서비스가 잘 동작하는지 궁금해서 30분정도 구경을 했다.
너무 많은 요청이 몰리는탓에 간간이 주문이 어렵거나 상품평들을 가져오지 못한 경우를 만났다
다만 가장 인상깊었던것 중 하나는 그 와중에도 상품 페이지는 그대로 유지가 되었는데 그래서 혹시 기술블로그에 이와 관련된 내용이 있을지 찾아봤다.
```

scale-out의 위험성:
```
이벤트로인해 순간적으로 트래픽이 몰리는경우가 발생했을때 scale-out은 항상 정답이 될 수 없다
지속적으로 많은 트래픽이 유입되는것이 아니라 순간순간 트래픽이 치솟기때문에 오히려 자원 낭비가 극심할 수 있다.
```

redis를 활용한 대기열 아키텍쳐:
```
redis의 경우 Sorted Set자료구조가 있는데 이는 Key, Score, Member의 형태로 이루어져 있으며 Score를 기반으로 정렬
- rdb를 활용하여 정렬하는것보다 성능적인 장점이 존재한다고 한다.
- 이러한 특성을 활용하여⭐️
- 개별 사용자의 Request에서 (Timestamp를 Score로), (사용자 식별 키 값을 Member로)사용하는 아이템을 Sorted Set에 저장
  - 즉 timeStamp => score / userId => member
- 설정된 유입량에 따라 낮은 Score의 아이템들을 제거해 나감으로써 마치 FIFO Queue와 같이 동작
  - 낮은 score는 아마 빨리 들어온 요청을 말하는듯
- 나아가 Timestamp로 기록된 Score를 활용하여 다양하고 섬세한 기능이 구현
```

동작과정:
- <img width="842" alt="스크린샷 2022-10-06 오후 8 48 45" src="https://user-images.githubusercontent.com/62214428/194305070-547fc955-8a1a-440b-b663-8e95a46c7475.png">
```
내 나름대로 이해를 해보면

우선 web service api는 대기열을 등록 및 조회하는 api 서비스로

1. 상품상세에 대한 사용자의 요청이 들어온다
  - 해당 요청을 바로 처리하는게 아니라 대기가 필요한지 먼저 파악한다.
  - 왜? 이걸하지않으면 모든 요청이 대해 상품상세 데이터를 요청하고 해당 서비스가 터지니까
  - 이를 위해 web service api에게 대기 필요 여부 조회요청
  
2. web service api는 먼저 대기열 세팅이 필요한지를 파악하기 위해 해당 상품 트래픽 정보를 redis에 저장

3. 해당 상품 요청이 대기열 등록되어있는지 redis에서 확인
- 자동 대기열 세팅이 되어있는지 파악하기 위해 Redis의 모든 자동 대기열 세팅 Key로 이루어진 데이터를 가져온다
- 해당 상품의 번호, 이벤트 타입 등의 조합으로 이루어진 Field를 찾는다.

4. 만약 대기열이 등록되어있지 않다면 2번에서 저장한 트래픽 정보를 가져와서 트래픽이 임계치 이상인지 비교
  - 만약 임계치 이하라면 바로 상품상세 정보를 보여주도록 반환
  
5. 특정 임계치 이상인 경우 대기열 등록을 위해 redis에 저장
  - Redis에 Wating이라는 이름을 가진 Key, 현재 시간을 Score, 유저 아이디와 상품 번호를 Member로 저장.
  
이후 loop를 돌면서 하나의 요청씩 상품 상세 페이지 요청을 처리한다고 생각
```

```
결국에 많은 요청속에서도 버틴 이유가 있었다고 생각한다.
물론 아직까지 완벽하게 이해하진 못하겠다.. 

사용자 요청은 당연히 먼저 요청한 사람이 우선되어야하니 timestamp를 score로 비교 정렬할 수 있었고
결국 동시다발적인 요청을 순차적으로 처리하면서 버틸 수 있었지않았나... 싶다.
문제를 해결하는 방법은 다양한거같고 많이 찾아보면서 생각해볼수있어야겠다.
```
